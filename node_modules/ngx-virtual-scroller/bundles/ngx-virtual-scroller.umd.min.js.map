{"version":3,"sources":["../../node_modules/tslib/tslib.es6.js","ng://ngx-virtual-scroller/virtual-scroller.ts"],"names":["__decorate","decorators","target","key","desc","d","c","arguments","length","r","Object","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","__metadata","metadataKey","metadataValue","metadata","VirtualScrollerComponent","element","renderer","zone","changeDetectorRef","platformId","scrollThrottlingTime","scrollDebounceTime","scrollAnimationTime","scrollbarWidth","scrollbarHeight","checkResizeInterval","resizeBypassRefreshThreshold","modifyOverflowStyleOfParentScroll","stripedTable","this","window","executeRefreshOutsideAngularZone","_enableUnequalChildrenSizes","useMarginInsteadOfTranslate","ssrViewportWidth","ssrViewportHeight","_bufferAmount","_checkResizeInterval","_items","compareItems","item1","item2","update","EventEmitter","vsUpdate","change","vsChange","start","vsStart","end","vsEnd","calculatedScrollbarWidth","calculatedScrollbarHeight","padding","previousViewPort","cachedPageSize","previousScrollNumberElements","isAngularUniversalSSR","isPlatformServer","horizontal","resetWrapGroupDimensions","prototype","pageInfo","startIndex","endIndex","scrollStartPosition","scrollEndPosition","maxScrollPosition","startIndexWithBuffer","endIndexWithBuffer","value","minMeasuredChildWidth","undefined","minMeasuredChildHeight","enableUnequalChildrenSizes","_scrollThrottlingTime","updateOnScrollFunction","_scrollDebounceTime","_this_1","onScroll","debounce","refresh_internal","throttleTrailing","addScrollEventHandlers","_horizontal","updateDirection","revertParentOverscroll","scrollElement","getScrollElement","oldParentScrollOverflow","style","y","x","_parentScroll","nativeElement","ngOnInit","ngOnDestroy","removeScrollEventHandlers","ngOnChanges","changes","indexLengthChanged","cachedItemsLength","items","firstRun","previousValue","ngDoCheck","refresh","invalidateAllCachedMeasurements","wrapGroupDimensions","maxChildSizePerWrapGroup","numberOfKnownWrapGroupChildSizes","sumOfKnownWrapGroupChildWidths","sumOfKnownWrapGroupChildHeights","invalidateCachedMeasurementForItem","item","index","indexOf","invalidateCachedMeasurementAtIndex","cachedMeasurement","childWidth","childHeight","scrollInto","alignToBeginning","additionalOffset","animationMilliseconds","animationCompletedCallback","scrollToIndex","maxRetries","retryIfNeeded","dimensions","calculateDimensions","desiredStartIndex","Math","min","max","itemCount","scrollToIndex_internal","scroll","calculatePadding","wrapGroupsPerPage","_childScrollDim","scrollToPosition","scrollPosition","getElementsOffset","animationRequest","currentTween","stop","setProperty","_scrollType","tweenConfigObj","newTween","tween.Tween","to","easing","tween.Easing","Quadratic","Out","onUpdate","data","isNaN","onStop","cancelAnimationFrame","animate","time","runOutsideAngular","requestAnimationFrame","checkScrollElementResized","sizeChanged","boundingRect","getBoundingClientRect","previousScrollBoundingRect","widthChange","abs","width","heightChange","height","_invisiblePaddingProperty","_offsetType","_pageOffsetType","_marginDir","_translateDir","func","wait","throttled","result","apply","timeout","_this","_arguments","setTimeout","clearTimeout","itemsArrayModified","refreshCompletedCallback","maxRunTimes","viewport","calculateViewport","startChanged","endChanged","scrollLengthChanged","scrollLength","paddingChanged","scrollPositionChanged","setStyle","invisiblePaddingElementRef","contentElementRef","headerElementRef","containerOffset","offset","clientHeight","changeEventArg","handleChanged","viewPortItems","slice","emit","markForCheck","run","parentScroll","Window","document","scrollingElement","documentElement","body","disposeScrollHandler","listen","disposeResizeHandler","checkScrollElementResizedTimer","setInterval","clearInterval","containerElementRef","elementClientRect","scrollClientRect","left","top","countItemsPerWrapGroup","round","ssrChildHeight","ssrChildWidth","propertyName","children","childrenLength","firstOffset","getScrollStartPosition","windowScrollValue","oldWrapGroupDimensions","itemsPerWrapGroup","wrapGroupIndex","oldWrapGroupDimension","itemsChanged","arrayStartIndex","offsetHeight","offsetWidth","clientWidth","defaultChildWidth","defaultChildHeight","viewportWidth","viewportHeight","content","itemsPerRow","ceil","itemsPerCol","scrollOffset","maxWidthForWrapGroup","maxHeightForWrapGroup","sumOfVisibleMaxWidths","sumOfVisibleMaxHeights","clientRect","oldValue","maxVisibleWidthForWrapGroup","scrollOffsetToRemove","maxVisibleHeightForWrapGroup","averageChildWidth","averageChildHeight","itemsPerPage","pageCount_fractional","numberOfWrapGroups","defaultScrollLengthPerWrapGroup","numUnknownChildSizes","childSize","viewportLength","arrayStartIndexWithBuffer","startingWrapGroupIndex","floor","calculatePageInfo","scrollPercentage","totalScrolledLength","startingArrayIndex_fractional","maxStart","bufferBoundary","arrayEndIndex","endIndexWithinWrapGroup","bufferSize","bufferAmount","newPadding","newScrollLength","tslib_1.__decorate","Input","Output","ViewChild","read","ElementRef","ContentChild","Component","selector","exportAs","template","host","[class.horizontal]","[class.vertical]","[class.selfScroll]","tslib_1.__param","Inject","PLATFORM_ID","Optional","Renderer2","NgZone","ChangeDetectorRef","VirtualScrollerModule","NgModule","exports","declarations","imports","CommonModule"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import {\r\n\tComponent,\r\n\tContentChild,\r\n\tElementRef,\r\n\tEventEmitter,\r\n\tInject,\r\n\tOptional,\r\n\tInput,\r\n\tNgModule,\r\n\tNgZone,\r\n\tOnChanges,\r\n\tOnDestroy,\r\n\tOnInit,\r\n\tOutput,\r\n\tRenderer2,\r\n\tViewChild,\r\n\tChangeDetectorRef\r\n} from '@angular/core';\r\n\r\nimport { PLATFORM_ID } from '@angular/core';\r\nimport { isPlatformServer } from '@angular/common';\r\n\r\nimport { CommonModule } from '@angular/common';\r\n\r\nimport * as tween from '@tweenjs/tween.js'\r\n\r\nexport interface WrapGroupDimensions {\r\n\tnumberOfKnownWrapGroupChildSizes: number;\r\n\tsumOfKnownWrapGroupChildWidths: number;\r\n\tsumOfKnownWrapGroupChildHeights: number;\r\n\tmaxChildSizePerWrapGroup: WrapGroupDimension[];\r\n}\r\n\r\nexport interface WrapGroupDimension {\r\n\tchildWidth: number;\r\n\tchildHeight: number;\r\n\titems: any[];\r\n}\r\n\r\nexport interface IDimensions {\r\n\titemCount: number;\r\n\titemsPerWrapGroup: number;\r\n\twrapGroupsPerPage: number;\r\n\titemsPerPage: number;\r\n\tpageCount_fractional: number;\r\n\tchildWidth: number;\r\n\tchildHeight: number;\r\n\tscrollLength: number;\r\n\tviewportLength: number;\r\n\tmaxScrollPosition: number;\r\n}\r\n\r\nexport interface IPageInfo {\r\n\tstartIndex: number;\r\n\tendIndex: number;\r\n\tscrollStartPosition: number;\r\n\tscrollEndPosition: number;\r\n\tstartIndexWithBuffer: number;\r\n\tendIndexWithBuffer: number;\r\n\tmaxScrollPosition: number;\r\n}\r\n\r\nexport interface ChangeEvent extends IPageInfo {\r\n\tstart: number;\r\n\tend: number;\r\n}\r\n\r\nexport interface IViewport extends IPageInfo {\r\n\tpadding: number;\r\n\tscrollLength: number;\r\n}\r\n\r\n@Component({\r\n\tselector: 'virtual-scroller,[virtualScroller]',\r\n\texportAs: 'virtualScroller',\r\n\ttemplate: `\r\n    <div class=\"total-padding\" #invisiblePadding></div>\r\n    <div class=\"scrollable-content\" #content>\r\n      <ng-content></ng-content>\r\n    </div>\r\n  `,\r\n\thost: {\r\n\t\t'[class.horizontal]': \"horizontal\",\r\n\t\t'[class.vertical]': \"!horizontal\",\r\n\t\t'[class.selfScroll]': \"!parentScroll\"\r\n\t},\r\n\tstyles: [`\r\n    :host {\r\n      position: relative;\r\n\t  display: block;\r\n      -webkit-overflow-scrolling: touch;\r\n    }\r\n\t\r\n\t:host.horizontal.selfScroll {\r\n      overflow-y: visible;\r\n      overflow-x: auto;\r\n\t}\r\n\t:host.vertical.selfScroll {\r\n      overflow-y: auto;\r\n      overflow-x: visible;\r\n\t}\r\n\t\r\n    .scrollable-content {\r\n      top: 0;\r\n      left: 0;\r\n      width: 100%;\r\n      height: 100%;\r\n      max-width: 100vw;\r\n      max-height: 100vh;\r\n      position: absolute;\r\n    }\r\n\r\n\t.scrollable-content ::ng-deep > * {\r\n\t\tbox-sizing: border-box;\r\n\t}\r\n\t\r\n\t:host.horizontal {\r\n\t\twhite-space: nowrap;\r\n\t}\r\n\t\r\n\t:host.horizontal .scrollable-content {\r\n\t\tdisplay: flex;\r\n\t}\r\n\t\r\n\t:host.horizontal .scrollable-content ::ng-deep > * {\r\n\t\tflex-shrink: 0;\r\n\t\tflex-grow: 0;\r\n\t\twhite-space: initial;\r\n\t}\r\n\t\r\n    .total-padding {\r\n      width: 1px;\r\n      opacity: 0;\r\n    }\r\n    \r\n    :host.horizontal .total-padding {\r\n      height: 100%;\r\n    }\r\n  `]\r\n})\r\nexport class VirtualScrollerComponent implements OnInit, OnChanges, OnDestroy {\r\n\tpublic viewPortItems: any[];\r\n\tpublic window = window;\r\n\r\n\tpublic get viewPortInfo(): IPageInfo {\r\n\t\tlet pageInfo: IViewport = this.previousViewPort || <any>{};\r\n\t\treturn {\r\n\t\t\tstartIndex: pageInfo.startIndex || 0,\r\n\t\t\tendIndex: pageInfo.endIndex || 0,\r\n\t\t\tscrollStartPosition: pageInfo.scrollStartPosition || 0,\r\n\t\t\tscrollEndPosition: pageInfo.scrollEndPosition || 0,\r\n\t\t\tmaxScrollPosition: pageInfo.maxScrollPosition || 0,\r\n\t\t\tstartIndexWithBuffer: pageInfo.startIndexWithBuffer || 0,\r\n\t\t\tendIndexWithBuffer: pageInfo.endIndexWithBuffer || 0\r\n\t\t};\r\n\t}\r\n\r\n\t@Input()\r\n\tpublic executeRefreshOutsideAngularZone: boolean = false;\r\n\t\r\n\tprotected _enableUnequalChildrenSizes: boolean = false;\r\n\t@Input()\r\n\tpublic get enableUnequalChildrenSizes(): boolean {\r\n\t\treturn this._enableUnequalChildrenSizes;\r\n\t}\r\n\tpublic set enableUnequalChildrenSizes(value: boolean) {\r\n\t\tif (this._enableUnequalChildrenSizes === value) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._enableUnequalChildrenSizes = value;\r\n\t\tthis.minMeasuredChildWidth = undefined;\r\n\t\tthis.minMeasuredChildHeight = undefined;\r\n\t}\r\n\r\n\t@Input()\r\n\tpublic useMarginInsteadOfTranslate: boolean = false;\r\n\t\r\n\t@Input()\r\n\tpublic modifyOverflowStyleOfParentScroll: boolean;\r\n\t\r\n\t@Input()\r\n\tpublic stripedTable: boolean;\r\n\r\n\t@Input()\r\n\tpublic scrollbarWidth: number;\r\n\r\n\t@Input()\r\n\tpublic scrollbarHeight: number;\r\n\r\n\t@Input()\r\n\tpublic childWidth: number;\r\n\r\n\t@Input()\r\n\tpublic childHeight: number;\r\n\r\n\t@Input()\r\n\tpublic ssrChildWidth: number;\r\n\r\n\t@Input()\r\n\tpublic ssrChildHeight: number;\r\n\r\n\t@Input()\r\n\tpublic ssrViewportWidth: number = 1920;\r\n\r\n\t@Input()\r\n\tpublic ssrViewportHeight: number = 1080;\r\n\r\n\tprotected _bufferAmount: number = 0;\r\n\t@Input()\r\n\tpublic get bufferAmount(): number {\r\n\t\tif (typeof (this._bufferAmount) === 'number' && this._bufferAmount >= 0) {\r\n\t\t\treturn this._bufferAmount;\r\n\t\t} else {\r\n\t\t\treturn this.enableUnequalChildrenSizes ? 5 : 0;\t\r\n\t\t}\r\n\t}\r\n\tpublic set bufferAmount(value: number) {\r\n\t\tthis._bufferAmount = value;\r\n\t}\r\n\r\n\t@Input()\r\n\tpublic scrollAnimationTime: number = 750;\r\n\r\n\t@Input()\r\n\tpublic resizeBypassRefreshThreshold: number = 5;\r\n\r\n\tprotected _scrollThrottlingTime: number;\r\n\t@Input()\r\n\tpublic get scrollThrottlingTime(): number {\r\n\t\treturn this._scrollThrottlingTime;\r\n\t}\r\n\tpublic set scrollThrottlingTime(value: number) {\r\n\t\tthis._scrollThrottlingTime = value;\r\n\t\tthis.updateOnScrollFunction();\r\n\t}\r\n\r\n\tprotected _scrollDebounceTime: number;\r\n\t@Input()\r\n\tpublic get scrollDebounceTime(): number {\r\n\t\treturn this._scrollDebounceTime;\r\n\t}\r\n\tpublic set scrollDebounceTime(value: number) {\r\n\t\tthis._scrollDebounceTime = value;\r\n\t\tthis.updateOnScrollFunction();\r\n\t}\r\n\r\n\tprotected onScroll: () => void;\r\n\tprotected updateOnScrollFunction(): void {\r\n\t\tif (this.scrollDebounceTime) {\r\n\t\t\tthis.onScroll = <any>this.debounce(() => {\r\n\t\t\t\tthis.refresh_internal(false);\r\n\t\t\t}, this.scrollDebounceTime);\r\n\t\t}\r\n\t\telse if (this.scrollThrottlingTime) {\r\n\t\t\tthis.onScroll = <any>this.throttleTrailing(() => {\r\n\t\t\t\tthis.refresh_internal(false);\r\n\t\t\t}, this.scrollThrottlingTime);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.onScroll = () => {\r\n\t\t\t\tthis.refresh_internal(false);\r\n\t\t\t};\r\n\t\t}\r\n\t}\r\n\r\n\tprotected checkScrollElementResizedTimer: number;\r\n\tprotected _checkResizeInterval: number = 1000;\r\n\t@Input()\r\n\tpublic get checkResizeInterval(): number {\r\n\t\treturn this._checkResizeInterval;\r\n\t}\r\n\tpublic set checkResizeInterval(value: number) {\r\n\t\tif (this._checkResizeInterval === value) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._checkResizeInterval = value;\r\n\t\tthis.addScrollEventHandlers();\r\n\t}\r\n\r\n\tprotected _items: any[] = [];\r\n\t@Input()\r\n\tpublic get items(): any[] {\r\n\t\treturn this._items;\r\n\t}\r\n\tpublic set items(value: any[]) {\r\n\t\tif (value === this._items) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._items = value || [];\r\n\t\tthis.refresh_internal(true);\r\n\t}\r\n\r\n\t@Input()\r\n\tpublic compareItems: (item1: any, item2: any) => boolean = (item1: any, item2: any) => item1 === item2;\r\n\r\n\tprotected _horizontal: boolean;\r\n\t@Input()\r\n\tpublic get horizontal(): boolean {\r\n\t\treturn this._horizontal;\r\n\t}\r\n\tpublic set horizontal(value: boolean) {\r\n\t\tthis._horizontal = value;\r\n\t\tthis.updateDirection();\r\n\t}\r\n\r\n\tprotected revertParentOverscroll(): void {\r\n\t\tconst scrollElement = this.getScrollElement();\r\n\t\tif (scrollElement && this.oldParentScrollOverflow) {\r\n\t\t\tscrollElement.style['overflow-y'] = this.oldParentScrollOverflow.y;\r\n\t\t\tscrollElement.style['overflow-x'] = this.oldParentScrollOverflow.x;\r\n\t\t}\r\n\r\n\t\tthis.oldParentScrollOverflow = undefined;\r\n\t}\r\n\r\n\tprotected oldParentScrollOverflow: { x: string, y: string };\r\n\tprotected _parentScroll: Element | Window;\r\n\t@Input()\r\n\tpublic get parentScroll(): Element | Window {\r\n\t\treturn this._parentScroll;\r\n\t}\r\n\tpublic set parentScroll(value: Element | Window) {\r\n\t\tif (this._parentScroll === value) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis.revertParentOverscroll();\r\n\t\tthis._parentScroll = value;\r\n\t\tthis.addScrollEventHandlers();\r\n\r\n\t\tconst scrollElement = this.getScrollElement();\r\n\t\tif (this.modifyOverflowStyleOfParentScroll && scrollElement !== this.element.nativeElement) {\r\n\t\t\tthis.oldParentScrollOverflow = { x: scrollElement.style['overflow-x'], y: scrollElement.style['overflow-y'] };\r\n\t\t\tscrollElement.style['overflow-y'] = this.horizontal ? 'visible' : 'auto';\r\n\t\t\tscrollElement.style['overflow-x'] = this.horizontal ? 'auto' : 'visible';\r\n\t\t}\r\n\t}\r\n\r\n\t@Output()\r\n\tpublic update: EventEmitter<any[]> = new EventEmitter<any[]>();\r\n\t@Output()\r\n\tpublic vsUpdate: EventEmitter<any[]> = new EventEmitter<any[]>();\r\n\r\n\t@Output()\r\n\tpublic change: EventEmitter<ChangeEvent> = new EventEmitter<ChangeEvent>();\r\n\t@Output()\r\n\tpublic vsChange: EventEmitter<ChangeEvent> = new EventEmitter<ChangeEvent>();\r\n\r\n\t@Output()\r\n\tpublic start: EventEmitter<ChangeEvent> = new EventEmitter<ChangeEvent>();\r\n\t@Output()\r\n\tpublic vsStart: EventEmitter<ChangeEvent> = new EventEmitter<ChangeEvent>();\r\n\r\n\t@Output()\r\n\tpublic end: EventEmitter<ChangeEvent> = new EventEmitter<ChangeEvent>();\r\n\t@Output()\r\n\tpublic vsEnd: EventEmitter<ChangeEvent> = new EventEmitter<ChangeEvent>();\r\n\r\n\t@ViewChild('content', { read: ElementRef })\r\n\tprotected contentElementRef: ElementRef;\r\n\r\n\t@ViewChild('invisiblePadding', { read: ElementRef })\r\n\tprotected invisiblePaddingElementRef: ElementRef;\r\n\r\n\t@ContentChild('header', { read: ElementRef })\r\n\tprotected headerElementRef: ElementRef;\r\n\r\n\t@ContentChild('container', { read: ElementRef })\r\n\tprotected containerElementRef: ElementRef;\r\n\r\n\tpublic ngOnInit(): void {\r\n\t\tthis.addScrollEventHandlers();\r\n\t}\r\n\r\n\tpublic ngOnDestroy(): void {\r\n\t\tthis.removeScrollEventHandlers();\r\n\t\tthis.revertParentOverscroll();\r\n\t}\r\n\r\n\tpublic ngOnChanges(changes: any): void {\r\n\t\tlet indexLengthChanged = this.cachedItemsLength !== this.items.length;\r\n\t\tthis.cachedItemsLength = this.items.length;\r\n\r\n\t\tconst firstRun: boolean = !changes.items || !changes.items.previousValue || changes.items.previousValue.length === 0;\r\n\t\tthis.refresh_internal(indexLengthChanged || firstRun);\r\n\t}\r\n\r\n\tpublic ngDoCheck(): void {\r\n\t\tif (this.cachedItemsLength !== this.items.length) {\r\n\t\t\tthis.cachedItemsLength = this.items.length;\r\n\t\t\tthis.refresh_internal(true);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic refresh(): void {\r\n\t\tthis.refresh_internal(true);\r\n\t}\r\n\r\n\tpublic invalidateAllCachedMeasurements(): void {\r\n\t\tthis.wrapGroupDimensions = {\r\n\t\t\tmaxChildSizePerWrapGroup: [],\r\n\t\t\tnumberOfKnownWrapGroupChildSizes: 0,\r\n\t\t\tsumOfKnownWrapGroupChildWidths: 0,\r\n\t\t\tsumOfKnownWrapGroupChildHeights: 0\r\n\t\t};\r\n\r\n\t\tthis.minMeasuredChildWidth = undefined;\r\n\t\tthis.minMeasuredChildHeight = undefined;\r\n\r\n\t\tthis.refresh_internal(false);\r\n\t}\r\n\r\n\tpublic invalidateCachedMeasurementForItem(item: any): void {\r\n\t\tif (this.enableUnequalChildrenSizes) {\r\n\t\t\tlet index = this.items && this.items.indexOf(item);\r\n\t\t\tif (index >= 0) {\r\n\t\t\t\tthis.invalidateCachedMeasurementAtIndex(index);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tthis.minMeasuredChildWidth = undefined;\r\n\t\t\tthis.minMeasuredChildHeight = undefined;\r\n\t\t}\r\n\r\n\t\tthis.refresh_internal(false);\r\n\t}\r\n\r\n\tpublic invalidateCachedMeasurementAtIndex(index: number): void {\r\n\t\tif (this.enableUnequalChildrenSizes) {\r\n\t\t\tlet cachedMeasurement = this.wrapGroupDimensions.maxChildSizePerWrapGroup[index];\r\n\t\t\tif (cachedMeasurement) {\r\n\t\t\t\tthis.wrapGroupDimensions.maxChildSizePerWrapGroup[index] = undefined;\r\n\t\t\t\t--this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;\r\n\t\t\t\tthis.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths -= cachedMeasurement.childWidth || 0;\r\n\t\t\t\tthis.wrapGroupDimensions.sumOfKnownWrapGroupChildHeights -= cachedMeasurement.childHeight || 0;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tthis.minMeasuredChildWidth = undefined;\r\n\t\t\tthis.minMeasuredChildHeight = undefined;\r\n\t\t}\r\n\r\n\t\tthis.refresh_internal(false);\r\n\t}\r\n\r\n\tpublic scrollInto(item: any, alignToBeginning: boolean = true, additionalOffset: number = 0, animationMilliseconds: number = undefined, animationCompletedCallback: () => void = undefined): void {\r\n\t\tlet index: number = this.items.indexOf(item);\r\n\t\tif (index === -1) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis.scrollToIndex(index, alignToBeginning, additionalOffset, animationMilliseconds, animationCompletedCallback);\r\n\t}\r\n\r\n\tpublic scrollToIndex(index: number, alignToBeginning: boolean = true, additionalOffset: number = 0, animationMilliseconds: number = undefined, animationCompletedCallback: () => void = undefined): void {\r\n\t\tlet maxRetries: number = 5;\r\n\r\n\t\tlet retryIfNeeded = () => {\r\n\t\t\t--maxRetries;\r\n\t\t\tif (maxRetries <= 0) {\r\n\t\t\t\tif (animationCompletedCallback) {\r\n\t\t\t\t\tanimationCompletedCallback();\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tlet dimensions = this.calculateDimensions();\r\n\t\t\tlet desiredStartIndex = Math.min(Math.max(index, 0), dimensions.itemCount - 1);\r\n\t\t\tif (this.previousViewPort.startIndex === desiredStartIndex) {\r\n\t\t\t\tif (animationCompletedCallback) {\r\n\t\t\t\t\tanimationCompletedCallback();\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tthis.scrollToIndex_internal(index, alignToBeginning, additionalOffset, 0, retryIfNeeded);\r\n\t\t};\r\n\r\n\t\tthis.scrollToIndex_internal(index, alignToBeginning, additionalOffset, animationMilliseconds, retryIfNeeded);\r\n\t}\r\n\r\n\tprotected scrollToIndex_internal(index: number, alignToBeginning: boolean = true, additionalOffset: number = 0, animationMilliseconds: number = undefined, animationCompletedCallback: () => void = undefined): void {\r\n\t\tanimationMilliseconds = animationMilliseconds === undefined ? this.scrollAnimationTime : animationMilliseconds;\r\n\r\n\t\tlet dimensions = this.calculateDimensions();\r\n\t\tlet scroll = this.calculatePadding(index, dimensions) + additionalOffset;\r\n\t\tif (!alignToBeginning) {\r\n\t\t\tscroll -= dimensions.wrapGroupsPerPage * dimensions[this._childScrollDim];\r\n\t\t}\r\n\r\n\t\tthis.scrollToPosition(scroll, animationMilliseconds, animationCompletedCallback);\r\n\t}\r\n\r\n\tpublic scrollToPosition(scrollPosition: number, animationMilliseconds: number = undefined, animationCompletedCallback: () => void = undefined): void {\r\n\t\tscrollPosition += this.getElementsOffset();\r\n\r\n\t\tanimationMilliseconds = animationMilliseconds === undefined ? this.scrollAnimationTime : animationMilliseconds;\r\n\r\n\t\tlet scrollElement = this.getScrollElement();\r\n\r\n\t\tlet animationRequest: number;\r\n\r\n\t\tif (this.currentTween) {\r\n\t\t\tthis.currentTween.stop();\r\n\t\t\tthis.currentTween = undefined;\r\n\t\t}\r\n\r\n\t\tif (!animationMilliseconds) {\r\n\t\t\tthis.renderer.setProperty(scrollElement, this._scrollType, scrollPosition);\r\n\t\t\tthis.refresh_internal(false, animationCompletedCallback);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconst tweenConfigObj = { scrollPosition: scrollElement[this._scrollType] };\r\n\r\n\t\tlet newTween = new tween.Tween(tweenConfigObj)\r\n\t\t\t.to({ scrollPosition }, animationMilliseconds)\r\n\t\t\t.easing(tween.Easing.Quadratic.Out)\r\n\t\t\t.onUpdate((data) => {\r\n\t\t\t\tif (isNaN(data.scrollPosition)) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tthis.renderer.setProperty(scrollElement, this._scrollType, data.scrollPosition);\r\n\t\t\t\tthis.refresh_internal(false);\r\n\t\t\t})\r\n\t\t\t.onStop(() => {\r\n\t\t\t\tcancelAnimationFrame(animationRequest);\r\n\t\t\t})\r\n\t\t\t.start();\r\n\r\n\t\tconst animate = (time?: number) => {\r\n\t\t\tif (!newTween[\"isPlaying\"]()) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tnewTween.update(time);\r\n\t\t\tif (tweenConfigObj.scrollPosition === scrollPosition) {\r\n\t\t\t\tthis.refresh_internal(false, animationCompletedCallback);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tthis.zone.runOutsideAngular(() => {\r\n\t\t\t\tanimationRequest = requestAnimationFrame(animate);\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\tanimate();\r\n\t\tthis.currentTween = newTween;\r\n\t}\r\n\r\n\tprotected isAngularUniversalSSR: boolean;\r\n\r\n\tconstructor(protected readonly element: ElementRef,\r\n\t\tprotected readonly renderer: Renderer2,\r\n\t\tprotected readonly zone: NgZone,\r\n\t\tprotected changeDetectorRef: ChangeDetectorRef,\r\n\t\t@Inject(PLATFORM_ID) platformId: Object,\r\n\t\t@Optional() @Inject('virtualScroller.scrollThrottlingTime') scrollThrottlingTime,\r\n\t\t@Optional() @Inject('virtualScroller.scrollDebounceTime') scrollDebounceTime,\r\n\t\t@Optional() @Inject('virtualScroller.scrollAnimationTime') scrollAnimationTime,\r\n\t\t@Optional() @Inject('virtualScroller.scrollbarWidth') scrollbarWidth,\r\n\t\t@Optional() @Inject('virtualScroller.scrollbarHeight') scrollbarHeight,\r\n\t\t@Optional() @Inject('virtualScroller.checkResizeInterval') checkResizeInterval,\r\n\t\t@Optional() @Inject('virtualScroller.resizeBypassRefreshThreshold') resizeBypassRefreshThreshold,\r\n\t\t@Optional() @Inject('virtualScroller.modifyOverflowStyleOfParentScroll') modifyOverflowStyleOfParentScroll,\r\n\t\t@Optional() @Inject('virtualScroller.stripedTable') stripedTable) {\r\n\t\tthis.isAngularUniversalSSR = isPlatformServer(platformId);\r\n\r\n\t\tthis.scrollThrottlingTime = typeof (scrollThrottlingTime) === 'number' ? scrollThrottlingTime : 0;\r\n\t\tthis.scrollDebounceTime = typeof (scrollDebounceTime) === 'number' ? scrollDebounceTime : 0;\r\n\r\n\t\tif (typeof (scrollAnimationTime) === 'number') {\r\n\t\t\tthis.scrollAnimationTime = scrollAnimationTime;\r\n\t\t}\r\n\t\tif (typeof (scrollbarWidth) === 'number') {\r\n\t\t\tthis.scrollbarWidth = scrollbarWidth;\r\n\t\t}\r\n\t\tif (typeof (scrollbarHeight) === 'number') {\r\n\t\t\tthis.scrollbarHeight = scrollbarHeight;\r\n\t\t}\r\n\t\tif (typeof (checkResizeInterval) === 'number') {\r\n\t\t\tthis.checkResizeInterval = checkResizeInterval;\r\n\t\t}\r\n\t\tif (typeof (resizeBypassRefreshThreshold) === 'number') {\r\n\t\t\tthis.resizeBypassRefreshThreshold = resizeBypassRefreshThreshold;\r\n\t\t}\r\n\t\t\r\n\t\tthis.modifyOverflowStyleOfParentScroll = true;\r\n\t\tif (typeof (modifyOverflowStyleOfParentScroll) === 'boolean') {\r\n\t\t\tthis.modifyOverflowStyleOfParentScroll = modifyOverflowStyleOfParentScroll;\r\n\t\t}\r\n\t\t\r\n\t\tthis.stripedTable = false;\r\n\t\tif (typeof (stripedTable) === 'boolean') {\r\n\t\t\tthis.stripedTable = stripedTable;\r\n\t\t}\r\n\r\n\t\tthis.horizontal = false;\r\n\t\tthis.resetWrapGroupDimensions();\r\n\t}\r\n\r\n\tprotected previousScrollBoundingRect: ClientRect;\r\n\tprotected checkScrollElementResized(): void {\r\n\t\tlet boundingRect = this.getScrollElement().getBoundingClientRect();\r\n\r\n\t\tlet sizeChanged: boolean;\r\n\t\tif (!this.previousScrollBoundingRect) {\r\n\t\t\tsizeChanged = true;\r\n\t\t} else {\r\n\t\t\tlet widthChange = Math.abs(boundingRect.width - this.previousScrollBoundingRect.width);\r\n\t\t\tlet heightChange = Math.abs(boundingRect.height - this.previousScrollBoundingRect.height);\r\n\t\t\tsizeChanged = widthChange > this.resizeBypassRefreshThreshold || heightChange > this.resizeBypassRefreshThreshold;\r\n\t\t}\r\n\r\n\t\tif (sizeChanged) {\r\n\t\t\tthis.previousScrollBoundingRect = boundingRect;\r\n\t\t\tif (boundingRect.width > 0 && boundingRect.height > 0) {\r\n\t\t\t\tthis.refresh_internal(false);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tprotected _invisiblePaddingProperty;\r\n\tprotected _offsetType;\r\n\tprotected _scrollType;\r\n\tprotected _pageOffsetType;\r\n\tprotected _childScrollDim;\r\n\tprotected _translateDir;\r\n\tprotected _marginDir;\r\n\tprotected updateDirection(): void {\r\n\t\tif (this.horizontal) {\r\n\t\t\tthis._invisiblePaddingProperty = 'width';\r\n\t\t\tthis._offsetType = 'offsetLeft';\r\n\t\t\tthis._pageOffsetType = 'pageXOffset';\r\n\t\t\tthis._childScrollDim = 'childWidth';\r\n\t\t\tthis._marginDir = 'margin-left';\r\n\t\t\tthis._translateDir = 'translateX';\r\n\t\t\tthis._scrollType = 'scrollLeft';\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis._invisiblePaddingProperty = 'height';\r\n\t\t\tthis._offsetType = 'offsetTop';\r\n\t\t\tthis._pageOffsetType = 'pageYOffset';\r\n\t\t\tthis._childScrollDim = 'childHeight';\r\n\t\t\tthis._marginDir = 'margin-top';\r\n\t\t\tthis._translateDir = 'translateY';\r\n\t\t\tthis._scrollType = 'scrollTop';\r\n\t\t}\r\n\t}\r\n\r\n\tprotected debounce(func: Function, wait: number): Function {\r\n\t\tconst throttled = this.throttleTrailing(func, wait);\r\n\t\tconst result = function () {\r\n\t\t\tthrottled['cancel']();\r\n\t\t\tthrottled.apply(this, arguments);\r\n\t\t};\r\n\t\tresult['cancel'] = function () {\r\n\t\t\tthrottled['cancel']();\r\n\t\t};\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\tprotected throttleTrailing(func: Function, wait: number): Function {\r\n\t\tlet timeout = undefined;\r\n\t\tconst result = function () {\r\n\t\t\tconst _this = this;\r\n\t\t\tconst _arguments = arguments;\r\n\r\n\t\t\tif (timeout) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (wait <= 0) {\r\n\t\t\t\tfunc.apply(_this, _arguments);\r\n\t\t\t} else {\r\n\t\t\t\ttimeout = setTimeout(function () {\r\n\t\t\t\t\ttimeout = undefined;\r\n\t\t\t\t\tfunc.apply(_this, _arguments);\r\n\t\t\t\t}, wait);\r\n\t\t\t}\r\n\t\t};\r\n\t\tresult['cancel'] = function () {\r\n\t\t\tif (timeout) {\r\n\t\t\t\tclearTimeout(timeout);\r\n\t\t\t\ttimeout = undefined;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\tprotected calculatedScrollbarWidth: number = 0;\r\n\tprotected calculatedScrollbarHeight: number = 0;\r\n\r\n\tprotected padding: number = 0;\r\n\tprotected previousViewPort: IViewport = <any>{};\r\n\tprotected currentTween: tween.Tween;\r\n\tprotected cachedItemsLength: number;\r\n\r\n\tprotected disposeScrollHandler: () => void | undefined;\r\n\tprotected disposeResizeHandler: () => void | undefined;\r\n\r\n\tprotected refresh_internal(itemsArrayModified: boolean, refreshCompletedCallback: () => void = undefined, maxRunTimes: number = 2): void {\r\n\t\t//note: maxRunTimes is to force it to keep recalculating if the previous iteration caused a re-render (different sliced items in viewport or scrollPosition changed).\r\n\t\t//The default of 2x max will probably be accurate enough without causing too large a performance bottleneck\r\n\t\t//The code would typically quit out on the 2nd iteration anyways. The main time it'd think more than 2 runs would be necessary would be for vastly different sized child items or if this is the 1st time the items array was initialized.\r\n\t\t//Without maxRunTimes, If the user is actively scrolling this code would become an infinite loop until they stopped scrolling. This would be okay, except each scroll event would start an additional infinte loop. We want to short-circuit it to prevent his.\r\n\r\n\t\tthis.zone.runOutsideAngular(() => {\r\n\t\t\trequestAnimationFrame(() => {\r\n\r\n\t\t\t\tif (itemsArrayModified) {\r\n\t\t\t\t\tthis.resetWrapGroupDimensions();\r\n\t\t\t\t}\r\n\t\t\t\tlet viewport = this.calculateViewport();\r\n\r\n\t\t\t\tlet startChanged = itemsArrayModified || viewport.startIndex !== this.previousViewPort.startIndex;\r\n\t\t\t\tlet endChanged = itemsArrayModified || viewport.endIndex !== this.previousViewPort.endIndex;\r\n\t\t\t\tlet scrollLengthChanged = viewport.scrollLength !== this.previousViewPort.scrollLength;\r\n\t\t\t\tlet paddingChanged = viewport.padding !== this.previousViewPort.padding;\r\n\t\t\t\tlet scrollPositionChanged = viewport.scrollStartPosition !== this.previousViewPort.scrollStartPosition || viewport.scrollEndPosition !== this.previousViewPort.scrollEndPosition || viewport.maxScrollPosition !== this.previousViewPort.maxScrollPosition;\r\n\r\n\t\t\t\tthis.previousViewPort = viewport;\r\n\r\n\t\t\t\tif (scrollLengthChanged) {\r\n\t\t\t\t\tthis.renderer.setStyle(this.invisiblePaddingElementRef.nativeElement, this._invisiblePaddingProperty, `${viewport.scrollLength}px`);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (paddingChanged) {\r\n\t\t\t\t\tif (this.useMarginInsteadOfTranslate) {\r\n\t\t\t\t\t\tthis.renderer.setStyle(this.contentElementRef.nativeElement, this._marginDir, `${viewport.padding}px`);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tthis.renderer.setStyle(this.contentElementRef.nativeElement, 'transform', `${this._translateDir}(${viewport.padding}px)`);\r\n\t\t\t\t\t\tthis.renderer.setStyle(this.contentElementRef.nativeElement, 'webkitTransform', `${this._translateDir}(${viewport.padding}px)`);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.headerElementRef) {\r\n\t\t\t\t\tlet scrollPosition = this.getScrollElement()[this._scrollType];\r\n\t\t\t\t\tlet containerOffset = this.getElementsOffset();\r\n\t\t\t\t\tlet offset = Math.max(scrollPosition - viewport.padding - containerOffset + this.headerElementRef.nativeElement.clientHeight, 0);\r\n\t\t\t\t\tthis.renderer.setStyle(this.headerElementRef.nativeElement, 'transform', `${this._translateDir}(${offset}px)`);\r\n\t\t\t\t\tthis.renderer.setStyle(this.headerElementRef.nativeElement, 'webkitTransform', `${this._translateDir}(${offset}px)`);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst changeEventArg: ChangeEvent = (startChanged || endChanged) ? {\r\n\t\t\t\t\tstart: viewport.startIndex,\r\n\t\t\t\t\tend: viewport.endIndex,\r\n\t\t\t\t\tstartIndex: viewport.startIndex,\r\n\t\t\t\t\tendIndex: viewport.endIndex,\r\n\t\t\t\t\tscrollStartPosition: viewport.scrollStartPosition,\r\n\t\t\t\t\tscrollEndPosition: viewport.scrollEndPosition,\r\n\t\t\t\t\tstartIndexWithBuffer: viewport.startIndexWithBuffer,\r\n\t\t\t\t\tendIndexWithBuffer: viewport.endIndexWithBuffer,\r\n\t\t\t\t\tmaxScrollPosition: viewport.maxScrollPosition\r\n\t\t\t\t} : undefined;\r\n\r\n\r\n\t\t\t\tif (startChanged || endChanged || scrollPositionChanged) {\r\n\t\t\t\t\tconst handleChanged = () => {\r\n\t\t\t\t\t\t// update the scroll list to trigger re-render of components in viewport\r\n\t\t\t\t\t\tthis.viewPortItems = viewport.startIndexWithBuffer >= 0 && viewport.endIndexWithBuffer >= 0 ? this.items.slice(viewport.startIndexWithBuffer, viewport.endIndexWithBuffer + 1) : [];\r\n\t\t\t\t\t\tthis.update.emit(this.viewPortItems);\r\n\t\t\t\t\t\tthis.vsUpdate.emit(this.viewPortItems);\r\n\r\n\t\t\t\t\t\tif (startChanged) {\r\n\t\t\t\t\t\t\tthis.start.emit(changeEventArg);\r\n\t\t\t\t\t\t\tthis.vsStart.emit(changeEventArg);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (endChanged) {\r\n\t\t\t\t\t\t\tthis.end.emit(changeEventArg);\r\n\t\t\t\t\t\t\tthis.vsEnd.emit(changeEventArg);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (startChanged || endChanged) {\r\n\t\t\t\t\t\t\tthis.changeDetectorRef.markForCheck();\r\n\t\t\t\t\t\t\tthis.change.emit(changeEventArg);\r\n\t\t\t\t\t\t\tthis.vsChange.emit(changeEventArg);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t\tif (maxRunTimes > 0) {\r\n\t\t\t\t\t\t\tthis.refresh_internal(false, refreshCompletedCallback, maxRunTimes - 1);\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (refreshCompletedCallback) {\r\n\t\t\t\t\t\t\trefreshCompletedCallback();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (this.executeRefreshOutsideAngularZone) {\r\n\t\t\t\t\t\thandleChanged();\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tthis.zone.run(handleChanged);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (maxRunTimes > 0 && (scrollLengthChanged || paddingChanged)) {\r\n\t\t\t\t\t\tthis.refresh_internal(false, refreshCompletedCallback, maxRunTimes - 1);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (refreshCompletedCallback) {\r\n\t\t\t\t\t\trefreshCompletedCallback();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n\r\n\tprotected getScrollElement(): HTMLElement {\r\n\t\treturn this.parentScroll instanceof Window ? document.scrollingElement || document.documentElement || document.body : this.parentScroll || this.element.nativeElement;\r\n\t}\r\n\r\n\tprotected addScrollEventHandlers(): void {\r\n\t\tif (this.isAngularUniversalSSR) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet scrollElement = this.getScrollElement();\r\n\r\n\t\tthis.removeScrollEventHandlers();\r\n\r\n\t\tthis.zone.runOutsideAngular(() => {\r\n\t\t\tif (this.parentScroll instanceof Window) {\r\n\t\t\t\tthis.disposeScrollHandler = this.renderer.listen('window', 'scroll', this.onScroll);\r\n\t\t\t\tthis.disposeResizeHandler = this.renderer.listen('window', 'resize', this.onScroll);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.disposeScrollHandler = this.renderer.listen(scrollElement, 'scroll', this.onScroll);\r\n\t\t\t\tif (this._checkResizeInterval > 0) {\r\n\t\t\t\t\tthis.checkScrollElementResizedTimer = <any>setInterval(() => { this.checkScrollElementResized(); }, this._checkResizeInterval);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tprotected removeScrollEventHandlers(): void {\r\n\t\tif (this.checkScrollElementResizedTimer) {\r\n\t\t\tclearInterval(this.checkScrollElementResizedTimer);\r\n\t\t}\r\n\r\n\t\tif (this.disposeScrollHandler) {\r\n\t\t\tthis.disposeScrollHandler();\r\n\t\t\tthis.disposeScrollHandler = undefined;\r\n\t\t}\r\n\r\n\t\tif (this.disposeResizeHandler) {\r\n\t\t\tthis.disposeResizeHandler();\r\n\t\t\tthis.disposeResizeHandler = undefined;\r\n\t\t}\r\n\t}\r\n\r\n\tprotected getElementsOffset(): number {\r\n\t\tif (this.isAngularUniversalSSR) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tlet offset = 0;\r\n\r\n\t\tif (this.containerElementRef && this.containerElementRef.nativeElement) {\r\n\t\t\toffset += this.containerElementRef.nativeElement[this._offsetType];\r\n\t\t}\r\n\r\n\t\tif (this.parentScroll) {\r\n\t\t\tlet scrollElement = this.getScrollElement();\r\n\t\t\tlet elementClientRect = this.element.nativeElement.getBoundingClientRect();\r\n\t\t\tlet scrollClientRect = scrollElement.getBoundingClientRect();\r\n\t\t\tif (this.horizontal) {\r\n\t\t\t\toffset += elementClientRect.left - scrollClientRect.left;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\toffset += elementClientRect.top - scrollClientRect.top;\r\n\t\t\t}\r\n\r\n\t\t\tif (!(this.parentScroll instanceof Window)) {\r\n\t\t\t\toffset += scrollElement[this._scrollType];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn offset;\r\n\t}\r\n\r\n\tprotected countItemsPerWrapGroup(): number {\r\n\t\tif (this.isAngularUniversalSSR) {\r\n\t\t\treturn Math.round(this.horizontal ? this.ssrViewportHeight / this.ssrChildHeight : this.ssrViewportWidth / this.ssrChildWidth);\r\n\t\t}\r\n\r\n\t\tlet propertyName = this.horizontal ? 'offsetLeft' : 'offsetTop';\r\n\t\tlet children = ((this.containerElementRef && this.containerElementRef.nativeElement) || this.contentElementRef.nativeElement).children;\r\n\r\n\t\tlet childrenLength = children ? children.length : 0;\r\n\t\tif (childrenLength === 0) {\r\n\t\t\treturn 1;\r\n\t\t}\r\n\r\n\t\tlet firstOffset = children[0][propertyName];\r\n\t\tlet result = 1;\r\n\t\twhile (result < childrenLength && firstOffset === children[result][propertyName]) {\r\n\t\t\t++result;\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\tprotected getScrollStartPosition(): number {\r\n\t\tlet windowScrollValue = undefined;\r\n\t\tif (this.parentScroll instanceof Window) {\r\n\t\t\twindowScrollValue = window[this._pageOffsetType];\r\n\t\t}\r\n\r\n\t\treturn windowScrollValue || this.getScrollElement()[this._scrollType] || 0;\r\n\t}\r\n\r\n\tprotected minMeasuredChildWidth: number;\r\n\tprotected minMeasuredChildHeight: number;\r\n\r\n\tprotected wrapGroupDimensions: WrapGroupDimensions;\r\n\r\n\tprotected resetWrapGroupDimensions(): void {\r\n\t\tconst oldWrapGroupDimensions = this.wrapGroupDimensions;\r\n\t\tthis.invalidateAllCachedMeasurements();\r\n\r\n\t\tif (!this.enableUnequalChildrenSizes || !oldWrapGroupDimensions || oldWrapGroupDimensions.numberOfKnownWrapGroupChildSizes === 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconst itemsPerWrapGroup: number = this.countItemsPerWrapGroup();\r\n\t\tfor (let wrapGroupIndex = 0; wrapGroupIndex < oldWrapGroupDimensions.maxChildSizePerWrapGroup.length; ++wrapGroupIndex) {\r\n\t\t\tconst oldWrapGroupDimension: WrapGroupDimension = oldWrapGroupDimensions.maxChildSizePerWrapGroup[wrapGroupIndex];\r\n\t\t\tif (!oldWrapGroupDimension || !oldWrapGroupDimension.items || !oldWrapGroupDimension.items.length) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tif (oldWrapGroupDimension.items.length !== itemsPerWrapGroup) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tlet itemsChanged = false;\r\n\t\t\tlet arrayStartIndex = itemsPerWrapGroup * wrapGroupIndex;\r\n\t\t\tfor (let i = 0; i < itemsPerWrapGroup; ++i) {\r\n\t\t\t\tif (!this.compareItems(oldWrapGroupDimension.items[i], this.items[arrayStartIndex + i])) {\r\n\t\t\t\t\titemsChanged = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (!itemsChanged) {\r\n\t\t\t\t++this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;\r\n\t\t\t\tthis.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths += oldWrapGroupDimension.childWidth || 0;\r\n\t\t\t\tthis.wrapGroupDimensions.sumOfKnownWrapGroupChildHeights += oldWrapGroupDimension.childHeight || 0;\r\n\t\t\t\tthis.wrapGroupDimensions.maxChildSizePerWrapGroup[wrapGroupIndex] = oldWrapGroupDimension;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tprotected calculateDimensions(): IDimensions {\r\n\t\tlet scrollElement = this.getScrollElement();\r\n\r\n\t\tconst maxCalculatedScrollBarSize: number = 25; // Note: Formula to auto-calculate doesn't work for ParentScroll, so we default to this if not set by consuming application\r\n\t\tthis.calculatedScrollbarHeight = Math.max(Math.min(scrollElement.offsetHeight - scrollElement.clientHeight, maxCalculatedScrollBarSize), this.calculatedScrollbarHeight);\r\n\t\tthis.calculatedScrollbarWidth = Math.max(Math.min(scrollElement.offsetWidth - scrollElement.clientWidth, maxCalculatedScrollBarSize), this.calculatedScrollbarWidth);\r\n\r\n\t\tlet viewportWidth = scrollElement.offsetWidth - (this.scrollbarWidth || this.calculatedScrollbarWidth || (this.horizontal ? 0 : maxCalculatedScrollBarSize));\r\n\t\tlet viewportHeight = scrollElement.offsetHeight - (this.scrollbarHeight || this.calculatedScrollbarHeight || (this.horizontal ? maxCalculatedScrollBarSize : 0));\r\n\r\n\t\tlet content = (this.containerElementRef && this.containerElementRef.nativeElement) || this.contentElementRef.nativeElement;\r\n\r\n\t\tlet itemsPerWrapGroup = this.countItemsPerWrapGroup();\r\n\t\tlet wrapGroupsPerPage;\r\n\r\n\t\tlet defaultChildWidth;\r\n\t\tlet defaultChildHeight;\r\n\r\n\t\tif (this.isAngularUniversalSSR) {\r\n\t\t\tviewportWidth = this.ssrViewportWidth;\r\n\t\t\tviewportHeight = this.ssrViewportHeight;\r\n\t\t\tdefaultChildWidth = this.ssrChildWidth;\r\n\t\t\tdefaultChildHeight = this.ssrChildHeight;\r\n\t\t\tlet itemsPerRow = Math.max(Math.ceil(viewportWidth / defaultChildWidth), 1);\r\n\t\t\tlet itemsPerCol = Math.max(Math.ceil(viewportHeight / defaultChildHeight), 1);\r\n\t\t\twrapGroupsPerPage = this.horizontal ? itemsPerRow : itemsPerCol;\r\n\t\t}\r\n\t\telse if (!this.enableUnequalChildrenSizes) {\r\n\t\t\tif (content.children.length > 0) {\r\n\t\t\t\tif (!this.childWidth || !this.childHeight) {\r\n\t\t\t\t\tif (!this.minMeasuredChildWidth && viewportWidth > 0) {\r\n\t\t\t\t\t\tthis.minMeasuredChildWidth = viewportWidth;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!this.minMeasuredChildHeight && viewportHeight > 0) {\r\n\t\t\t\t\t\tthis.minMeasuredChildHeight = viewportHeight;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet child = content.children[0];\r\n\t\t\t\tlet clientRect = child.getBoundingClientRect();\r\n\t\t\t\tthis.minMeasuredChildWidth = Math.min(this.minMeasuredChildWidth, clientRect.width);\r\n\t\t\t\tthis.minMeasuredChildHeight = Math.min(this.minMeasuredChildHeight, clientRect.height);\r\n\t\t\t}\r\n\r\n\t\t\tdefaultChildWidth = this.childWidth || this.minMeasuredChildWidth || viewportWidth;\r\n\t\t\tdefaultChildHeight = this.childHeight || this.minMeasuredChildHeight || viewportHeight;\r\n\t\t\tlet itemsPerRow = Math.max(Math.ceil(viewportWidth / defaultChildWidth), 1);\r\n\t\t\tlet itemsPerCol = Math.max(Math.ceil(viewportHeight / defaultChildHeight), 1);\r\n\t\t\twrapGroupsPerPage = this.horizontal ? itemsPerRow : itemsPerCol;\r\n\t\t} else {\r\n\t\t\tlet scrollOffset = scrollElement[this._scrollType] - (this.previousViewPort ? this.previousViewPort.padding : 0);\r\n\r\n\t\t\tlet arrayStartIndex = this.previousViewPort.startIndexWithBuffer || 0;\r\n\t\t\tlet wrapGroupIndex = Math.ceil(arrayStartIndex / itemsPerWrapGroup);\r\n\r\n\t\t\tlet maxWidthForWrapGroup = 0;\r\n\t\t\tlet maxHeightForWrapGroup = 0;\r\n\t\t\tlet sumOfVisibleMaxWidths = 0;\r\n\t\t\tlet sumOfVisibleMaxHeights = 0;\r\n\t\t\twrapGroupsPerPage = 0;\r\n\r\n\t\t\tfor (let i = 0; i < content.children.length; ++i) {\r\n\t\t\t\t++arrayStartIndex;\r\n\t\t\t\tlet child = content.children[i];\r\n\t\t\t\tlet clientRect = child.getBoundingClientRect();\r\n\r\n\t\t\t\tmaxWidthForWrapGroup = Math.max(maxWidthForWrapGroup, clientRect.width);\r\n\t\t\t\tmaxHeightForWrapGroup = Math.max(maxHeightForWrapGroup, clientRect.height);\r\n\r\n\t\t\t\tif (arrayStartIndex % itemsPerWrapGroup === 0) {\r\n\t\t\t\t\tlet oldValue = this.wrapGroupDimensions.maxChildSizePerWrapGroup[wrapGroupIndex];\r\n\t\t\t\t\tif (oldValue) {\r\n\t\t\t\t\t\t--this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;\r\n\t\t\t\t\t\tthis.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths -= oldValue.childWidth || 0;\r\n\t\t\t\t\t\tthis.wrapGroupDimensions.sumOfKnownWrapGroupChildHeights -= oldValue.childHeight || 0;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t++this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;\r\n\t\t\t\t\tconst items = this.items.slice(arrayStartIndex - itemsPerWrapGroup, arrayStartIndex);\r\n\t\t\t\t\tthis.wrapGroupDimensions.maxChildSizePerWrapGroup[wrapGroupIndex] = {\r\n\t\t\t\t\t\tchildWidth: maxWidthForWrapGroup,\r\n\t\t\t\t\t\tchildHeight: maxHeightForWrapGroup,\r\n\t\t\t\t\t\titems: items\r\n\t\t\t\t\t};\r\n\t\t\t\t\tthis.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths += maxWidthForWrapGroup;\r\n\t\t\t\t\tthis.wrapGroupDimensions.sumOfKnownWrapGroupChildHeights += maxHeightForWrapGroup;\r\n\r\n\t\t\t\t\tif (this.horizontal) {\r\n\t\t\t\t\t\tlet maxVisibleWidthForWrapGroup = Math.min(maxWidthForWrapGroup, Math.max(viewportWidth - sumOfVisibleMaxWidths, 0));\r\n\t\t\t\t\t\tif (scrollOffset > 0) {\r\n\t\t\t\t\t\t\tlet scrollOffsetToRemove = Math.min(scrollOffset, maxVisibleWidthForWrapGroup);\r\n\t\t\t\t\t\t\tmaxVisibleWidthForWrapGroup -= scrollOffsetToRemove;\r\n\t\t\t\t\t\t\tscrollOffset -= scrollOffsetToRemove;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tsumOfVisibleMaxWidths += maxVisibleWidthForWrapGroup;\r\n\t\t\t\t\t\tif (maxVisibleWidthForWrapGroup > 0 && viewportWidth >= sumOfVisibleMaxWidths) {\r\n\t\t\t\t\t\t\t++wrapGroupsPerPage;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tlet maxVisibleHeightForWrapGroup = Math.min(maxHeightForWrapGroup, Math.max(viewportHeight - sumOfVisibleMaxHeights, 0));\r\n\t\t\t\t\t\tif (scrollOffset > 0) {\r\n\t\t\t\t\t\t\tlet scrollOffsetToRemove = Math.min(scrollOffset, maxVisibleHeightForWrapGroup);\r\n\t\t\t\t\t\t\tmaxVisibleHeightForWrapGroup -= scrollOffsetToRemove;\r\n\t\t\t\t\t\t\tscrollOffset -= scrollOffsetToRemove;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tsumOfVisibleMaxHeights += maxVisibleHeightForWrapGroup;\r\n\t\t\t\t\t\tif (maxVisibleHeightForWrapGroup > 0 && viewportHeight >= sumOfVisibleMaxHeights) {\r\n\t\t\t\t\t\t\t++wrapGroupsPerPage;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t++wrapGroupIndex;\r\n\r\n\t\t\t\t\tmaxWidthForWrapGroup = 0;\r\n\t\t\t\t\tmaxHeightForWrapGroup = 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tlet averageChildWidth = this.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths / this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;\r\n\t\t\tlet averageChildHeight = this.wrapGroupDimensions.sumOfKnownWrapGroupChildHeights / this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;\r\n\t\t\tdefaultChildWidth = this.childWidth || averageChildWidth || viewportWidth;\r\n\t\t\tdefaultChildHeight = this.childHeight || averageChildHeight || viewportHeight;\r\n\r\n\t\t\tif (this.horizontal) {\r\n\t\t\t\tif (viewportWidth > sumOfVisibleMaxWidths) {\r\n\t\t\t\t\twrapGroupsPerPage += Math.ceil((viewportWidth - sumOfVisibleMaxWidths) / defaultChildWidth);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (viewportHeight > sumOfVisibleMaxHeights) {\r\n\t\t\t\t\twrapGroupsPerPage += Math.ceil((viewportHeight - sumOfVisibleMaxHeights) / defaultChildHeight);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet itemCount = this.items.length;\r\n\t\tlet itemsPerPage = itemsPerWrapGroup * wrapGroupsPerPage;\r\n\t\tlet pageCount_fractional = itemCount / itemsPerPage;\r\n\t\tlet numberOfWrapGroups = Math.ceil(itemCount / itemsPerWrapGroup);\r\n\r\n\t\tlet scrollLength = 0;\r\n\r\n\t\tlet defaultScrollLengthPerWrapGroup = this.horizontal ? defaultChildWidth : defaultChildHeight;\r\n\t\tif (this.enableUnequalChildrenSizes) {\r\n\t\t\tlet numUnknownChildSizes = 0;\r\n\t\t\tfor (let i = 0; i < numberOfWrapGroups; ++i) {\r\n\t\t\t\tlet childSize = this.wrapGroupDimensions.maxChildSizePerWrapGroup[i] && this.wrapGroupDimensions.maxChildSizePerWrapGroup[i][this._childScrollDim];\r\n\t\t\t\tif (childSize) {\r\n\t\t\t\t\tscrollLength += childSize;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t++numUnknownChildSizes;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tscrollLength += Math.round(numUnknownChildSizes * defaultScrollLengthPerWrapGroup);\r\n\t\t} else {\r\n\t\t\tscrollLength = numberOfWrapGroups * defaultScrollLengthPerWrapGroup;\r\n\t\t}\r\n\t\t\r\n\t\tif(this.headerElementRef){\r\n\t\t    scrollLength += this.headerElementRef.nativeElement.clientHeight;\r\n\t\t}\r\n\r\n\t\tlet viewportLength = this.horizontal ? viewportWidth : viewportHeight;\r\n\t\tlet maxScrollPosition = Math.max(scrollLength - viewportLength, 0);\r\n\r\n\t\treturn {\r\n\t\t\titemCount: itemCount,\r\n\t\t\titemsPerWrapGroup: itemsPerWrapGroup,\r\n\t\t\twrapGroupsPerPage: wrapGroupsPerPage,\r\n\t\t\titemsPerPage: itemsPerPage,\r\n\t\t\tpageCount_fractional: pageCount_fractional,\r\n\t\t\tchildWidth: defaultChildWidth,\r\n\t\t\tchildHeight: defaultChildHeight,\r\n\t\t\tscrollLength: scrollLength,\r\n\t\t\tviewportLength: viewportLength,\r\n\t\t\tmaxScrollPosition: maxScrollPosition\r\n\t\t};\r\n\t}\r\n\r\n\tprotected cachedPageSize: number = 0;\r\n\tprotected previousScrollNumberElements: number = 0;\r\n\r\n\tprotected calculatePadding(arrayStartIndexWithBuffer: number, dimensions: IDimensions): number {\r\n\t\tif (dimensions.itemCount === 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tlet defaultScrollLengthPerWrapGroup = dimensions[this._childScrollDim];\r\n\t\tlet startingWrapGroupIndex = Math.floor(arrayStartIndexWithBuffer / dimensions.itemsPerWrapGroup) || 0;\r\n\r\n\t\tif (!this.enableUnequalChildrenSizes) {\r\n\t\t\treturn defaultScrollLengthPerWrapGroup * startingWrapGroupIndex;\r\n\t\t}\r\n\r\n\t\tlet numUnknownChildSizes = 0;\r\n\t\tlet result = 0;\r\n\t\tfor (let i = 0; i < startingWrapGroupIndex; ++i) {\r\n\t\t\tlet childSize = this.wrapGroupDimensions.maxChildSizePerWrapGroup[i] && this.wrapGroupDimensions.maxChildSizePerWrapGroup[i][this._childScrollDim];\r\n\t\t\tif (childSize) {\r\n\t\t\t\tresult += childSize;\r\n\t\t\t} else {\r\n\t\t\t\t++numUnknownChildSizes;\r\n\t\t\t}\r\n\t\t}\r\n\t\tresult += Math.round(numUnknownChildSizes * defaultScrollLengthPerWrapGroup);\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\tprotected calculatePageInfo(scrollPosition: number, dimensions: IDimensions): IPageInfo {\r\n\t\tlet scrollPercentage = 0;\r\n\t\tif (this.enableUnequalChildrenSizes) {\r\n\t\t\tconst numberOfWrapGroups = Math.ceil(dimensions.itemCount / dimensions.itemsPerWrapGroup);\r\n\t\t\tlet totalScrolledLength = 0;\r\n\t\t\tlet defaultScrollLengthPerWrapGroup = dimensions[this._childScrollDim];\r\n\t\t\tfor (let i = 0; i < numberOfWrapGroups; ++i) {\r\n\t\t\t\tlet childSize = this.wrapGroupDimensions.maxChildSizePerWrapGroup[i] && this.wrapGroupDimensions.maxChildSizePerWrapGroup[i][this._childScrollDim];\r\n\t\t\t\tif (childSize) {\r\n\t\t\t\t\ttotalScrolledLength += childSize;\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttotalScrolledLength += defaultScrollLengthPerWrapGroup;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (scrollPosition < totalScrolledLength) {\r\n\t\t\t\t\tscrollPercentage = i / numberOfWrapGroups;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tscrollPercentage = scrollPosition / dimensions.scrollLength;\r\n\t\t}\r\n\r\n\t\tlet startingArrayIndex_fractional = Math.min(Math.max(scrollPercentage * dimensions.pageCount_fractional, 0), dimensions.pageCount_fractional) * dimensions.itemsPerPage;\r\n\r\n\t\tlet maxStart = dimensions.itemCount - dimensions.itemsPerPage - 1;\r\n\t\tlet arrayStartIndex = Math.min(Math.floor(startingArrayIndex_fractional), maxStart);\r\n\t\tarrayStartIndex -= arrayStartIndex % dimensions.itemsPerWrapGroup; // round down to start of wrapGroup\r\n\t\t\r\n\t\tif (this.stripedTable) {\r\n\t\t\tlet bufferBoundary = 2*dimensions.itemsPerWrapGroup;\r\n\t\t\tif (arrayStartIndex % bufferBoundary !== 0) {\t\t\t\r\n\t\t\t\tarrayStartIndex = Math.max(arrayStartIndex - arrayStartIndex%bufferBoundary, 0);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet arrayEndIndex = Math.ceil(startingArrayIndex_fractional) + dimensions.itemsPerPage - 1;\r\n\t\tlet endIndexWithinWrapGroup = (arrayEndIndex + 1) % dimensions.itemsPerWrapGroup;\r\n\t\tif (endIndexWithinWrapGroup > 0) {\r\n\t\t\tarrayEndIndex += dimensions.itemsPerWrapGroup - endIndexWithinWrapGroup; // round up to end of wrapGroup\r\n\t\t}\r\n\r\n\t\tif (isNaN(arrayStartIndex)) {\r\n\t\t\tarrayStartIndex = 0;\r\n\t\t}\r\n\t\tif (isNaN(arrayEndIndex)) {\r\n\t\t\tarrayEndIndex = 0;\r\n\t\t}\r\n\r\n\t\tarrayStartIndex = Math.min(Math.max(arrayStartIndex, 0), dimensions.itemCount - 1);\r\n\t\tarrayEndIndex = Math.min(Math.max(arrayEndIndex, 0), dimensions.itemCount - 1);\r\n\r\n\t\tlet bufferSize = this.bufferAmount * dimensions.itemsPerWrapGroup;\r\n\t\tlet startIndexWithBuffer = Math.min(Math.max(arrayStartIndex - bufferSize, 0), dimensions.itemCount - 1);\r\n\t\tlet endIndexWithBuffer = Math.min(Math.max(arrayEndIndex + bufferSize, 0), dimensions.itemCount - 1);\r\n\r\n\t\treturn {\r\n\t\t\tstartIndex: arrayStartIndex,\r\n\t\t\tendIndex: arrayEndIndex,\r\n\t\t\tstartIndexWithBuffer: startIndexWithBuffer,\r\n\t\t\tendIndexWithBuffer: endIndexWithBuffer,\r\n\t\t\tscrollStartPosition: scrollPosition,\r\n\t\t\tscrollEndPosition: scrollPosition + dimensions.viewportLength,\r\n\t\t\tmaxScrollPosition: dimensions.maxScrollPosition\r\n\t\t};\r\n\t}\r\n\r\n\tprotected calculateViewport(): IViewport {\r\n\t\tlet dimensions = this.calculateDimensions();\r\n\t\tlet offset = this.getElementsOffset();\r\n\r\n\t\tlet scrollStartPosition = this.getScrollStartPosition();\r\n\t\tif (scrollStartPosition > (dimensions.scrollLength + offset) && !(this.parentScroll instanceof Window)) {\r\n\t\t\tscrollStartPosition = dimensions.scrollLength;\r\n\t\t} else {\r\n\t\t\tscrollStartPosition -= offset;\r\n\t\t}\r\n\t\tscrollStartPosition = Math.max(0, scrollStartPosition);\r\n\r\n\t\tlet pageInfo = this.calculatePageInfo(scrollStartPosition, dimensions);\r\n\t\tlet newPadding = this.calculatePadding(pageInfo.startIndexWithBuffer, dimensions);\r\n\t\tlet newScrollLength = dimensions.scrollLength;\r\n\r\n\t\treturn {\r\n\t\t\tstartIndex: pageInfo.startIndex,\r\n\t\t\tendIndex: pageInfo.endIndex,\r\n\t\t\tstartIndexWithBuffer: pageInfo.startIndexWithBuffer,\r\n\t\t\tendIndexWithBuffer: pageInfo.endIndexWithBuffer,\r\n\t\t\tpadding: Math.round(newPadding),\r\n\t\t\tscrollLength: Math.round(newScrollLength),\r\n\t\t\tscrollStartPosition: pageInfo.scrollStartPosition,\r\n\t\t\tscrollEndPosition: pageInfo.scrollEndPosition,\r\n\t\t\tmaxScrollPosition: pageInfo.maxScrollPosition\r\n\t\t};\r\n\t}\r\n}\r\n\r\n@NgModule({\r\n\texports: [VirtualScrollerComponent],\r\n\tdeclarations: [VirtualScrollerComponent],\r\n\timports: [CommonModule]\r\n\r\n})\r\nexport class VirtualScrollerModule { }\r\n"]}